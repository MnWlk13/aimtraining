<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Treinamento De Mira</title>
    <style>
        /* Estilos aqui... */
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="optionsButton">Opções</button>
    <div id="endScreen" style="display: none;">
        <!-- Conteúdo da tela de vitória aqui... -->
    </div>
    <div id="loseScreen" style="display: none;">
        <!-- Conteúdo da tela de derrota aqui... -->
    </div>
    <div id="optionsScreen" style="display: none;">
        <!-- Conteúdo da tela de opções aqui... -->
    </div>
    <p id="score">Pontuação: 10</p>
    <p id="timer" style="display: none;">Tempo: 0s</p>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const blockSize = 50;
        const gridWidth = canvas.width / blockSize;
        const gridHeight = canvas.height / blockSize;
        let world = [];
        let score = 10; // Pontuação inicial
        let breakableBlocksRemaining = 0;
        let endScreenDisplayed = false;
        let gameStarted = false;
        let startTime = 0;
        let endTime = 0;

        // Recuperar histórico de pontuações do armazenamento local
        let scoreHistory = JSON.parse(localStorage.getItem('scoreHistory')) || [];

        // Texturas de blocos
        const woodTexture = new Image();
        woodTexture.src = 'images2.jpeg';
        const grassTexture = new Image();
        grassTexture.src = 'images3.jpeg';

        function generateWorld() {
            breakableBlocksRemaining = 0;
            for (let i = 0; i < gridWidth; i++) {
                world[i] = [];
                for (let j = 0; j < gridHeight; j++) {
                    const random = Math.random();
                    if (random < 0.2) {
                        world[i][j] = 1; // 1 represents a breakable block
                        breakableBlocksRemaining++;
                    } else {
                        world[i][j] = 0; // 0 represents empty space or grass block
                    }
                }
            }
        }

        function drawWorld() {
            for (let i = 0; i < gridWidth; i++) {
                for (let j = 0; j < gridHeight; j++) {
                    if (world[i][j] === 1) {
                        // Desenhar textura de madeira para blocos quebráveis
                        ctx.drawImage(woodTexture, i * blockSize, j * blockSize, blockSize, blockSize);
                    } else {
                        // Desenhar textura de grama para blocos vazios
                        ctx.drawImage(grassTexture, i * blockSize, j * blockSize, blockSize, blockSize);
                    }
                }
            }
        }

        function destroyBlock(x, y) {
            const blockX = Math.floor(x / blockSize);
            const blockY = Math.floor(y / blockSize);
            if (world[blockX] && world[blockX][blockY]) {
                if (world[blockX][blockY] === 1) {
                    world[blockX][blockY] = 0;
                    score += 10; // Increase score by 10 when a breakable block is destroyed
                    breakableBlocksRemaining--;
                    if (breakableBlocksRemaining === 0 && !endScreenDisplayed) {
                        endGame();
                    }
                    if (!gameStarted) {
                        gameStarted = true;
                        startTime = Date.now();
                        document.getElementById('timer').style.display = 'block';
                        startTimer();
                    }
                }
                updateScore();
            } else {
                score -= 20; // Subtract 20 points if the player clicks on any empty space
                updateScore();
            }
        }

        function updateScore() {
            const scoreElement = document.getElementById('score');
            scoreElement.textContent = 'Pontuação: ' + score;
            if (score <= 0 && !endScreenDisplayed) {
                showLoseScreen();
            }
        }

        function endGame() {
            endScreenDisplayed = true;
            endTime = Date.now();
            const endScreen = document.getElementById('endScreen');
            endScreen.style.display = 'block';
            const finalScoreElement = document.getElementById('finalScore');
            finalScoreElement.textContent = score;
            const finalTimeElement = document.getElementById('finalTime');
            const elapsedTime = (endTime - startTime) / 1000;
            finalTimeElement.textContent = elapsedTime.toFixed(2) + 's';
            document.getElementById('restartButtonEnd').addEventListener('click', restartGame);
            // Adicionar a pontuação atual ao histórico
            scoreHistory.push({ score: score, time: elapsedTime.toFixed(2) });
            // Ordenar o histórico de pontuações pelos menores tempos
            scoreHistory.sort((a, b) => parseFloat(a.time) - parseFloat(b.time));
            // Salvar apenas os 5 menores tempos no histórico
            scoreHistory = scoreHistory.slice(0, 5);
            // Salvar o histórico de pontuações no armazenamento local
            localStorage.setItem('scoreHistory', JSON.stringify(scoreHistory));
            // Exibir o histórico de pontuações
            displayScoreHistory();
        }

        function showLoseScreen() {
            const loseScreen = document.getElementById('loseScreen');
            endTime = Date.now();
            loseScreen.style.display = 'block';
            const finalTimeElement = document.getElementById('finalTimeLose');
            const elapsedTime = (endTime - startTime) / 1000;
            finalTimeElement.textContent = elapsedTime.toFixed(2) + 's';
            document.getElementById('restartButtonLose').addEventListener('click', restartGame);
            // Exibir o histórico de pontuações
            displayScoreHistory();
        }

        function restartGame() {
            location.reload();
        }

        function toggleOptionsScreen() {
            const optionsScreen = document.getElementById('optionsScreen');
            optionsScreen.style.display = optionsScreen.style.display === 'none' ? 'block' : 'none';
        }

        function closeOptions() {
            const optionsScreen = document.getElementById('optionsScreen');
            optionsScreen.style.display = 'none';
        }

        function setBombOption() {
            generateWorld(); // Regenerate world when bomb option changes
            closeOptions();
        }

        function resetScores() {
            // Limpar o histórico de pontuações no armazenamento local
            localStorage.removeItem('scoreHistory');
            // Atualizar a exibição do histórico de pontuações (opcional)
            displayScoreHistory();
        }

        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            destroyBlock(mouseX, mouseY);
        });

        generateWorld();

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            requestAnimationFrame(draw);
        }

        draw();

        // Função para iniciar o timer
        function startTimer() {
            setInterval(function() {
                if (!endScreenDisplayed) {
                    const currentTime = Date.now();
                    const elapsedTime = (currentTime - startTime) / 1000;
                    document.getElementById('timer').textContent = 'Tempo: ' + elapsedTime.toFixed(2) + 's';
                }
            }, 100);
        }

        // Função para exibir o histórico de pontuações
        function displayScoreHistory() {
            const scoreListItems = document.getElementById('scoreListItems');
            scoreListItems.innerHTML = '';
            scoreHistory.forEach(function(item, index) {
                const li = document.createElement('li');
                li.textContent = `Pontuação: ${item.score}, Tempo: ${item.time}s`;
                scoreListItems.appendChild(li);
            });
            document.getElementById('scoreList').style.display = 'block';
        }

        document.getElementById('optionsButton').addEventListener('click', toggleOptionsScreen);
        document.getElementById('closeOptions').addEventListener('click', closeOptions);
        document.getElementById('bombOption').addEventListener('change', setBombOption);
        document.getElementById('resetScoresButton').addEventListener('click', resetScores);
        document.getElementById('fullscreenButton').addEventListener('click', fullscreen);

        // Função para alternar para o modo de tela cheia
        function fullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }
    </script>
</body>
</html>
